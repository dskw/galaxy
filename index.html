<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Spiral galaxy</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<style>
			body {
				background-color: black;
				background-image: url("./images/stars.png"), url("./images/twinkling.png");
				margin: 0px;
				overflow: hidden;
				color: white;
				font-family: helvetica, sans-serif;
			}
		</style>
	</head>
	<body>
		<div id="message"></div>
		<div id="container"></div>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/lib/alea.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 ca;

			varying vec3 vColor;

			vec3 col(float k) {
				float T = k*32000.;
				vec3 c = vec3(1.,3.375,8.)/(exp((19e3*vec3(1.,1.5,2.)/T)) - 1.); // Planck law
				return c / max(c.r,max(c.g,c.b));  // chrominance
			}

			void main() {

				vColor = col(ca.r);

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size;
				gl_PointSize = size * ( 100.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>
		
		<script>
			function randomRangeFloat(input, min, max)
			{
				return input * ((max - min) + 1) + min;
			}
			
			function randomRange(rng, min, max)
			{
				return ~~(randomRangeFloat(rng.double(), min, max));
			}

			function invertedSCurve(value, min, max) {
				// Normalize value to [0, 1]
				let normalized = (value - min) / (max - min);

				// Apply the inverted sigmoid function for a curve that starts at 1 and decreases towards 0
				let scurved = 1 - 1 / (1 + Math.exp(-10 * (normalized - 0.5)));

				return scurved;
			}

			function makeStarBasic(seed)
			{
				let rng = new alea(seed);
				
				let temperature = randomRangeFloat(rng.double() / 10, 2000, 40000);
				let size = randomRange(rng, 20, 50)*2;
				let num_planets = randomRange(rng, 0, 5);
				let name = "star";//generateNameFromWordList(rng.int32(), starNameDB);

				// Calculate the position in the spiral
				const numArms = 5;
				const numStars = 5000;
				const maxDist = 25;
				const starIndex = seed >> 8;

				let armIndex = starIndex % numArms;
				let distanceRatio = Math.pow((starIndex / numStars), 3); // Squaring the ratio increases star density towards the center

				// Spiral parameters
				let spiralAngle = armIndex * (2 * Math.PI / numArms) + distanceRatio * 2 * Math.PI;
				let distanceFromCenter = Math.sqrt(distanceRatio) * maxDist; // We apply the square root to reverse the squaring operation we did earlier

				let arm_spread = 1-distanceRatio;
				
				// Cartesian coordinates calculation
				let x = distanceFromCenter * Math.cos(spiralAngle) + (rng.double() - 0.5) * 4 * arm_spread + (rng.double() - 0.5);
				let z = distanceFromCenter * Math.sin(spiralAngle) + (rng.double() - 0.5) * 4 * arm_spread + (rng.double() - 0.5);
				let y = Math.expm1(1 - (distanceFromCenter / maxDist)) * (rng.double()*2-1);

				return {
					size: size,
					temperature: temperature,
					seed: seed,
					name: name,
					position: {x:x, y:y, z:z},
					planets: new Array(num_planets)
				};
			}
			
			
			function calculateStarColor(temperature)
			{
				const b = 2.898e-3; // Wien's displacement constant in meters per Kelvin

				// Calculate the wavelength at which the star emits the most intensity
				const wavelength = b / temperature;

				// Map the wavelength to an RGB color
				let red, green, blue;

				if (wavelength < 450e-9) {
					red = 0;
					green = 0;
					blue = 255;
				} else if (wavelength < 495e-9) {
					red = 0;
					green = Math.round((wavelength - 450e-9) / (495e-9 - 450e-9) * 255);
					blue = 255;
				} else if (wavelength < 520e-9) {
					red = 0;
					green = 255;
					blue = Math.round((520e-9 - wavelength) / (520e-9 - 495e-9) * 255);
				} else if (wavelength < 565e-9) {
					red = Math.round((wavelength - 520e-9) / (565e-9 - 520e-9) * 255);
					green = 255;
					blue = 0;
				} else if (wavelength < 590e-9) {
					red = 255;
					green = Math.round((590e-9 - wavelength) / (590e-9 - 565e-9) * 255);
					blue = 0;
				} else if (wavelength < 620e-9) {
					red = 255;
					green = 0;
					blue = 0;
				} else {
					red = 255;
					green = 0;
					blue = 0;
				}

				//return [ red, green, blue ];
				return ((1 << 24) | ((red << 16) | (green << 8) | blue));
			}
		</script>

		<script>

			var mouseX = 0, mouseY = 0,

			windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2,

			camera, scene, renderer, particleSystem;

			var PI2 = Math.PI * 2;
			
			const GALAXY_SEED = 0;
			const NUM_STARS = 5000;
			var starDB = [];




			init();
			animate();

			function init() {

				var container, galaxy;

				container = document.createElement('div');
				document.body.appendChild(container);

				//intialize camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
				camera.position.z = 30;
				camera.position.y = 30;

				// Add OrbitControls so that we can pan around with the mouse.
				controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );


				//initialize scene
				scene = new THREE.Scene();
				
				// Render the scene.
				renderer = Detector.webgl? new THREE.WebGLRenderer(): document.getElementById("message").textContent = "Your browser does not support WebGL.";
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// Generate the circle texture
				var circleTexture = new THREE.Texture(generateCircleTexture());
				circleTexture.needsUpdate = true;

				// Set up the shaders
				attributes = {
					size: {	type: 'f', value: [] },
					ca:   {	type: 'c', value: [] }
				};

				uniforms = {
					amplitude: { type: "f", value: 1.0 },
					color:     { type: "c", value: new THREE.Color( 0xffffff ) },
					texture:   { type: "t", value: circleTexture },
				};

				uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;

				var shaderMaterial = new THREE.ShaderMaterial( {
					uniforms: 		uniforms,
					attributes:     attributes,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					transparent:	true
				});

				// Galaxy properties
				var galaxy = new THREE.Geometry();
				var arms = 5;
				var starsPerArm = NUM_STARS / arms;
				var armAngle = 270 / arms;
				
				for (let i = 0; i < NUM_STARS; ++i) {
					let starSeed = i << 8 | GALAXY_SEED;
					//let starSeed = i;
					let starData = makeStarBasic(starSeed);
					starDB[i] = starData;
					let p = new THREE.Vector3(starData.position.x, starData.position.y, starData.position.z);
					galaxy.vertices.push(p);
				}

				// Create the particle system
				//https://code.tutsplus.com/tutorials/webgl-with-threejs-textures-particles--net-35836
				particleSystem = new THREE.ParticleSystem(galaxy, shaderMaterial);
				particleSystem.sortParticles = true;
				
				// Data to send to the shader
				var vertices = particleSystem.geometry.vertices;
				var values_size = attributes.size.value;
				var values_color = attributes.ca.value;
				console.log("vertices = " + vertices.length);

				// Color variation
				for( var v = 0; v < vertices.length; v++ ) {
					let starData = starDB[v];
					values_size[ v ] = starData.size / 100.0;
					values_color[ v ] = new THREE.Color( starData.temperature/16000.0, 1, 1 );
					//values_color[ v ] = new THREE.Color( calculateStarColor(starData.temperature) );
				}

				// Add the particle system to the scene
				scene.add(particleSystem);

				// Resize listener
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function generateCircleTexture() {

				// draw a circle in the center of the canvas
				var size = 64;

				// create canvas
				var canvas = document.createElement('canvas');
				canvas.width = size;
				canvas.height = size;

				// get context
				var context = canvas.getContext('2d');

				// draw circle
				var centerX = size / 2;
				var centerY = size / 2;
				var radius = size / 2;

				for(var i = 1; i < 33; i++) {
					context.beginPath();
					context.arc(centerX, centerY, (radius / 2) + (i / 2), 0, 2 * Math.PI, false);
					context.fillStyle = "rgba(255, 255, 255, " + (1 / i) + ")";
					context.fill();
				}

				return canvas;
			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {
				
				//particleSystem.rotation.y += 0.0001;

				controls.update();
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				// camera.lookAt(scene.position);
				renderer.render( scene, camera );

			}

			function rand() {
				return Math.random() - 0.5;
			}

		</script>

	</body>
</html>
